from datetime import datetime
import logging

from chromadb import PersistentClient

from ollama import OllamaLLM


logging.basicConfig(
    filename='Use_Case_3/Use_Case_3.2/backend/backend.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    encoding='utf-8'
)

# Initialisiere Chroma mit persistentem Speicher
client = PersistentClient(path="./Use_Case_3/Use_Case_3.2/backend/chroma_storage")

# Erstelle oder erhalte eine Sammlung (Collection)
vectorstore = client.get_or_create_collection(
    name="conversation_context"
)
logger = logging.getLogger(__name__)

class ChatAgent:
    def __init__(self, vectorstore):
        """
        Initializes the ChatAgent with a given vector store.

        Args:
            vectorstore: The vector store to be used by the ChatAgent.
        """
        self.vectorstore = vectorstore

    def chat(self, user_input):
        """
        Handles the chat interaction with the user by retrieving the context, generating a prompt for the AI, 
        and storing the conversation context.
        Args:
            user_input (str): The input provided by the user for the chat.
        Returns:
            dict: A dictionary containing the log of the chat interaction and the final response from the AI.
                - log (dict): Contains details about the chat interaction.
                    - agent (str): The name of the agent handling the chat.
                    - status (str): The status of the chat interaction (running, completed, or failed).
                    - details (list): Additional details about the chat interaction.
                    - output (str): The final response from the AI or error message if failed.
                - final_response (str): The final response generated by the AI based on the context and user input.
        Raises:
            Exception: If an error occurs during the chat interaction, it is caught and logged, and an error message is returned.
        """
        log = {"agent": "ChatAgent", "status": "running", "details": []}
        try:
            # Kontext abrufen
            logger.debug("Rufe den vollständigen Kontext ab...")
            context = self.get_context_all()
            logger.debug(f"Erhaltener Kontext:\n{context}")

            # Aktualisierter Prompt für die KI
            prompt = f"""
            Dies ist ein fortlaufender Chat. Der Kontext enthält alle vorherigen Interaktionen zwischen dem Benutzer und der KI.

            Kontext:
            {context}

            Neue Benutzeranfrage:
            {user_input}

            Basierend auf dem Kontext und der neuen Anfrage, gib bitte eine passende Antwort:
            """
            logger.debug(f"Prompt für ChatAgent:\n{prompt}")
            
            # KI anfragen
            llm = OllamaLLM()
            response = llm._call(prompt).strip()
            logger.debug(f"Antwort von LLM:\n{response}")

            # Kontext speichern
            self.store_context("User Input", user_input)
            self.store_context("AI Response", response)

            log.update({
                "status": "completed",
                "output": response,
                "details": ["Chat erfolgreich abgeschlossen."]
            })
            return {"log": log, "final_response": response}
        
        except Exception as e:
            log.update({"status": "failed", "output": f"Fehler: {str(e)}"})
            logger.error(f"Fehler im ChatAgent: {e}")
            return {"log": log, "final_response": f"Fehler: {str(e)}"}

    def get_next_document_id(self):
        """
        Determines the next document ID based on the number of stored documents.

        This method retrieves all stored data from the vector store and calculates
        the next document ID by counting the existing IDs. If an error occurs during
        data retrieval, it logs the error and returns "1" as a fallback ID.

        Returns:
            str: The next document ID as a string.
        """
        try:
            all_data = self.vectorstore.get()  # Alle Daten abrufen
            existing_ids = all_data.get("ids", [])
            return str(len(existing_ids) + 1)
        except Exception as e:
            logger.error(f"Fehler beim Abrufen der nächsten ID: {e}")
            return "1"  # Fallback auf ID "1", falls ein Fehler auftritt

    def store_context(self, label, data):
        """
        Stores the context in ChromaDB with a sequential ID.
        Args:
            label (str): The label associated with the context data.
            data (str): The context data to be stored.
        Raises:
            Exception: If there is an error while storing the context.
        Logs:
            Info: Logs the label and data being stored along with the document ID.
            Debug: Logs a message indicating successful storage.
            Error: Logs any error that occurs during the storage process.
        """
        try:
            doc_id = self.get_next_document_id()  # Zugriff auf die Instanzmethode
            metadata = {"timestamp": datetime.now().isoformat()}
            logger.info(f"Speichere Kontext: {label} -> {data} (ID: {doc_id})")  # Nur die ersten 100 Zeichen loggen

            # Dokument speichern
            self.vectorstore.upsert(
                documents=[f"{label}: {data}"],
                ids=[doc_id],
                metadatas=[metadata]
            )
            logger.debug("Speichern erfolgreich.")
        except Exception as e:
            logger.error(f"Fehler beim Speichern des Kontexts: {e}")

    def get_context(self):
        """
        Retrieves the stored context from ChromaDB.

        This method queries all documents from the collection in the vector store.
        If successful, it returns the concatenated documents as a single string.
        If an error occurs, it logs the error and returns a default context message.

        Returns:
            str: The concatenated documents or a default context message if an error occurs.
        """
        try:
            logger.debug("Abfrage aller Dokumente aus der Collection.")
            results = self.vectorstore.get()  # Alle Dokumente abrufen
            documents = results.get("documents", [])
            logger.info(f"Kontext erfolgreich abgerufen: {len(documents)} Dokument(e) gefunden.")
            return "\n".join(documents)
        except Exception as e:
            logger.error(f"Fehler beim Abrufen des Kontexts: {e}")
            return "Standardkontext: Keine vorherigen Daten gefunden."

    def get_context_all(self):
        """
        Retrieves all documents from the vector store.
        This method attempts to fetch all documents stored in the vector store collection.
        If no documents are found, it logs a warning and returns a message indicating that no documents are available.
        If documents are successfully retrieved, it logs the number of documents and returns them as a single string, 
        with each document separated by a newline character.
        Returns:
            str: A string containing all documents separated by newlines, or a message indicating no documents are available.
        """
        try:
            results = self.vectorstore.get()  # Alle Daten aus der Collection abrufen
            documents = results.get("documents", [])
            if not documents:
                logger.warning("Keine gespeicherten Dokumente gefunden.")
                return "Keine gespeicherten Dokumente verfügbar."
            logger.info(f"{len(documents)} Dokument(e) erfolgreich abgerufen.")
            return "\n".join(documents)
        except Exception as e:
            logger.error(f"Fehler beim Abrufen aller Dokumente: {e}")
            return "Standardkontext: Keine Dokumente gefunden."
